\documentclass[onecolumn,11pt,nocopyrightspace]{sigplanconf}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors}

\begin{document}
\authorinfo{Fran√ßois Pottier}{Inria Paris}{francois.pottier@inria.fr}
\maketitle

% ------------------------------------------------------------------------------

% TEMPORARY
\clearpage
% \tableofcontents
% \clearpage

% ------------------------------------------------------------------------------

\section{Introduction}

\subsection{Setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
In order to use the \visitors package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Furthermore, a Merlin user should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

\subsection{A first example}

\begin{figure}[t]
In an OCaml source file, a type definition can be annotated with
\oc|[@@deriving visitors { ... }]|:
\orig{expr00}
This causes the following code to be (invisibly) generated:
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

Suppose we wish to work with arithmetic expressions built out of integer
literals and binary additions. An algebraic data type \oc|expr| is shown in
the first part of \fref{fig:expr00}. By annotating this type definition with
\oc|[@@deriving visitors { ... }]|, we request the automated generation of
a visitor for expressions. The code for this visitor, which in normal use
remains invisible, is shown in the second part of \fref{fig:expr00}.

The annotation \oc|[@@deriving visitors { ... }]| must carry at least two
parameters. The parameter \name can be an arbitrary string; it is used as the
name of the generated class. The parameter \variety must be one of \iter,
\map, \itertwo, \maptwo. It indicates which variety of visitor must be
generated.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

A visitor of the \iter variety traverses a data structure. It returns no
result: its methods have return type \unit. The default implementations of
these methods do nothing. In \fref{fig:expr00}, for instance, the method
\tyconvisitor{expr} inspects its argument \oc|this_expr| and recursively
invokes either \dataconvisitor{EConst} or \dataconvisitor{EAdd}, as
appropriate. The method \dataconvisitor{EConst} does nothing. (More precisely,
it calls the function \oc|VisitorsRuntime.Int.iter|, which itself does
nothing.) The method \dataconvisitor{EAdd} performs two recursive calls to
\tyconvisitor{expr}, which does nothing, so \dataconvisitor{EAdd} itself does
nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused.
% The type of this environment is therefore a priori undetermined.

\begin{figure}[t]
\begin{origenv}
\lstinputlisting[firstline=3]{expr04.ml}
\end{origenv}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to obtain a nontrivial behavior. Suppose,
for instance, that we wish to count the number of addition nodes in an
expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| which is both a counter (that is, it has a mutable
field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{An visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}

% ------------------------------------------------------------------------------

\end{document}
