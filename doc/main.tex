\documentclass[onecolumn,11pt,nocopyrightspace]{sigplanconf}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors}

\begin{document}
\authorinfo{Fran√ßois Pottier}{Inria Paris}{francois.pottier@inria.fr}
\maketitle

% ------------------------------------------------------------------------------

% TEMPORARY
\clearpage
% \tableofcontents
% \clearpage

% ------------------------------------------------------------------------------

\section{Introduction}
\label{sec:intro}

\subsection{Setup}
\label{sec:intro:setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
In order to use the \visitors package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Furthermore, a \merlin user should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

\begin{figure}[t]
In an OCaml source file, a type definition can be annotated with
\oc|[@@deriving visitors { ... }]|:
\orig{expr00}
This causes the following code to be (invisibly) generated:
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

\subsection{\iter visitors: definition}
\label{sec:intro:iter:def}

Suppose we wish to work with arithmetic expressions built out of integer
literals and binary additions. An algebraic data type \oc|expr| is shown in
the first part of \fref{fig:expr00}. By annotating this type definition with
\oc|[@@deriving visitors { ... }]|, we request the automated generation of
a visitor for expressions. The code for this visitor, which in normal use
remains invisible, is shown in the second part of \fref{fig:expr00}.

The annotation \oc|[@@deriving visitors { ... }]| must carry at least two
parameters. The parameter \name can be an arbitrary string; it is used as the
name of the generated class. The parameter \variety must be one of \iter,
\map, \itertwo, \maptwo. It indicates which variety of visitor must be
generated.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

A visitor of the \iter variety traverses a data structure. It returns no
result: its methods have return type \unit. The default implementations of
these methods do nothing. In \fref{fig:expr00}, for instance, the method
\tyconvisitor{expr} inspects its argument \oc|this_expr| and recursively
invokes either \dataconvisitor{EConst} or \dataconvisitor{EAdd}, as
appropriate. The method \dataconvisitor{EConst} does nothing. (More precisely,
it calls the function \oc|VisitorsRuntime.Int.iter|, which itself does
nothing.) The method \dataconvisitor{EAdd} performs two recursive calls to
\tyconvisitor{expr}, which does nothing, so \dataconvisitor{EAdd} itself does
nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused.
% The type of this environment is therefore a priori undetermined.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\begin{origenv}
\lstinputlisting[firstline=3]{expr04.ml}
\end{origenv}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

\subsection{\iter visitors: usage}
\label{sec:intro:iter:usage}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to obtain a nontrivial behavior. Suppose,
for instance, that we wish to count the number of addition nodes in an
expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| which is both a counter (that is, it has a mutable
field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

This may seem a rather complicated way of counting the addition nodes in an
expression. Of course, one could give a direct recursive definition of the
function \oc|count|, in a few lines of code, without using a visitor at all.
The point of employing a visitor, as done in Figures~\ref{fig:expr00}
and~\ref{fig:expr04}, is that no changes to the code are required when the
type of expressions is extended with new cases.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

\subsection{\map visitors}
\label{sec:intro:map}

A visitor of the \iter variety (\sref{sec:intro:iter:def}) returns no result.
Although, as illustrated previously (\sref{sec:intro:iter:usage}), it can use
private mutable state to accumulate information, there are applications for
which such a visitor is not suitable. One class of such applications is tree
transformations. For this purpose, one must use a visitor of another variety,
namely \map.

How to request the generation of a \map visitor is shown in the first part of
\fref{fig:expr01}. The generated code appears in the second part of
\fref{fig:expr01}. In comparison with the \iter visitor of \fref{fig:expr00},
the code is identical, except that, instead of returning \oc|()|, the method
\dataconvisitor{EConst} reconstructs an \oc|EConst| expression, and the method
\dataconvisitor{EAdd} reconstructs an \oc|EAdd| expression.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{A visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}

\begin{figure}[p]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}

\subsection{Visitors of arity two}
\label{sec:intro:aritytwo}

The \iter and \map visitors shown so far traverse one tree at a time. There
are situations where one wishes to simultaneously traverse two trees, which
one expects have the same structure. For this purpose, one should use a
visitor of arity 2. These come in two varities, namely \itertwo
(\fref{fig:expr02}) and \maptwo (\fref{fig:expr03}).

In these visitors, the method \tyconvisitor{expr} expects an environment and
two expressions. The two expressions must have identical structure: indeed, if
the method \tyconvisitor{expr} finds that the two expressions exhibit
different tags at the root, say \oc|EConst| versus \oc|EAdd|, then it invokes
the method \tyconfail{expr}, which by default calls \oc|VisitorsRuntime.fail()|,
which throws the exception \oc|VisitorsRuntime.StructuralMismatch|.

\begin{figure}[t]
\begin{origenv}
\lstinputlisting[firstline=3]{expr05.ml}
\end{origenv}
\caption{Determining whether two expressions are syntactically equal}
\label{fig:expr05}
\end{figure}

An \itertwo visitor can be used, for instance, to easily determine whether two
expressions are syntactically equal (\fref{fig:expr05}). Naturally, for this
particular purpose, one could use OCaml's primitive equality operator \oc|=|,
or one could exploit \ppxderiving and annotate the type definition with
\oc|[@@deriving eq]|. Visitors offer greater flexibility: for instance, if our
arithmetic expressions contained variables, we could easily define an
operation that tests whether two expressions are equal up to a renaming of
variables.
% More generally, if expressions contained variables and binders, we could
% define an operation that tests whether two expressions are $\alpha$-equivalent.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr06}
\caption{Visitors for a family of types}
\label{fig:expr06}
\end{figure}

\subsection{Visitors for a family of types}
\label{sec:intro:family}

Visitors can be generated not just for one type definition, but for a family
of type definitions. In \fref{fig:expr06}, we propose a definition of
arithmetic expressions that involves three algebraic data types, namely
\oc|unop|, \oc|binop|, and \oc|expr|. We request the generation of two
visitors, namely an \iter visitor and a \map visitor. This causes the
generation of just two classes, named \iter and \map, respectively. Each of
these classes has visitor methods for every type (namely \tyconvisitor{unop},
\tyconvisitor{binop}, \tyconvisitor{expr}) and for every data constructor
(namely \dataconvisitor{UnaryMinus}, \dataconvisitor{BinaryMinus}, and so on).

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr09}
\vspace{-\baselineskip}
\processed{expr09}
\caption{Visitors for parameterized types}
\label{fig:expr09}
\end{figure}

\subsection{Visitors for parameterized types}
\label{sec:intro:parameterized}



% ------------------------------------------------------------------------------

% TEMPORARY traitement des types non locaux (et primitifs)

% ------------------------------------------------------------------------------

\end{document}

% TEMPORARY

indiquer comment voir le code engendr√©
      et comment voir son type

related work:
  ppx_deriving (generates monolithic code) (fixed number of templates)
  ppx_deriving_morphism
  Hongbo Zhang has `deriving at a distance' in Fan
    https://github.com/bobzhang/fan
    http://zhanghongbo.me/fan/
    http://zhanghongbo.me/fan/_downloads/metaprogramming_for_ocaml.pdf
