\documentclass[11pt,a4paper,twoside]{article}
\usepackage[left=25mm,right=25mm,top=25mm,bottom=25mm,marginparwidth=50pt]{geometry}
\setlength\abovecaptionskip{0pt} % Reduce space above figure captions.
\usepackage{lmodern} % This gives us a bold monospace font.
\renewcommand{\rmdefault}{ptm} % Times.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{marginnote}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}
% Style.
\renewcommand{\emph}[1]{\textbf{#1}}
\input{version}

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors\\\normalsize version \visitorsversion}
\date{}
\begin{document}
\author{Fran√ßois Pottier\\ Inria Paris\\ \email{francois.pottier@inria.fr}}
\maketitle

% ------------------------------------------------------------------------------

\clearpage
\tableofcontents
\clearpage

% ------------------------------------------------------------------------------

\section{Introduction}
\label{sec:intro}

\subsection{Setup}
\label{sec:intro:setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
In order to use the \visitors package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Furthermore, a \merlin user should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

\begin{figure}[t]
% In an OCaml source file, a type definition can be annotated with
% \oc|[@@deriving visitors { ... }]|:
\orig{expr00}
% This causes the following code to be (invisibly) generated:
\vspace{-\baselineskip}
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

\subsection{\iter visitors: definition}
\label{sec:intro:iter:def}

Suppose we wish to work with arithmetic expressions built out of integer
literals and binary additions. An algebraic data type \oc|expr| is shown in
the first part of \fref{fig:expr00}. By annotating this type definition with
\oc|[@@deriving visitors { ... }]|, we request the automated generation of
a visitor for expressions. The code for this visitor, which in normal use
remains invisible, is shown in the second part of \fref{fig:expr00}.

The annotation \oc|[@@deriving visitors { ... }]| must carry at least two
parameters. The parameter \name can be an arbitrary string; it is used as the
name of the generated class. The parameter \variety must be one of \iter,
\map, \itertwo, \maptwo. It indicates which variety of visitor must be
generated.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

A visitor of the \iter variety traverses a data structure. It returns no
result: its methods have return type \unit. The default implementations of
these methods do nothing. In \fref{fig:expr00}, for instance, the method
\tyconvisitor{expr} inspects its argument \oc|this_expr| and recursively
invokes either \dataconvisitor{EConst} or \dataconvisitor{EAdd}, as
appropriate. The method \dataconvisitor{EConst} does nothing. (More precisely,
it calls the function \oc|VisitorsRuntime.Int.iter|, which itself does
nothing.) The method \dataconvisitor{EAdd} performs two recursive calls to
\tyconvisitor{expr}, which does nothing, so \dataconvisitor{EAdd} itself does
nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused.
% The type of this environment is therefore a priori undetermined.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\codefollowup{expr00}
\origfirstline{expr04}{3}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

\subsection{\iter visitors: usage}
\label{sec:intro:iter:usage}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to obtain a nontrivial behavior. Suppose,
for instance, that we wish to count the number of addition nodes in an
expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| which is both a counter (that is, it has a mutable
field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

This may seem a rather complicated way of counting the addition nodes in an
expression. Of course, one could give a direct recursive definition of the
function \oc|count|, in a few lines of code, without using a visitor at all.
The point of employing a visitor, as done in Figures~\ref{fig:expr00}
and~\ref{fig:expr04}, is that no changes to the code are required when the
type of expressions is extended with new cases.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

\subsection{\map visitors}
\label{sec:intro:map}

A visitor of the \iter variety (\sref{sec:intro:iter:def}) returns no result.
Although, as illustrated previously (\sref{sec:intro:iter:usage}), it can use
private mutable state to accumulate information, there are applications for
which such a visitor is not suitable. One class of such applications is tree
transformations. For this purpose, one must use a visitor of another variety,
namely \map.

How to request the generation of a \map visitor is shown in the first part of
\fref{fig:expr01}. The generated code appears in the second part of
\fref{fig:expr01}. In comparison with the \iter visitor of \fref{fig:expr00},
the code is identical, except that, instead of returning \oc|()|, the method
\dataconvisitor{EConst} reconstructs an \oc|EConst| expression, and the method
\dataconvisitor{EAdd} reconstructs an \oc|EAdd| expression.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{A visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}

\begin{figure}[p]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}

\subsection{Visitors of arity two}
\label{sec:intro:aritytwo}

The \iter and \map visitors shown so far traverse one tree at a time. There
are situations where one wishes to simultaneously traverse two trees, which
one expects have the same structure. For this purpose, one should use a
visitor of arity 2. These come in two varities, namely \itertwo
(\fref{fig:expr02}) and \maptwo (\fref{fig:expr03}).

In these visitors, the method \tyconvisitor{expr} expects an environment and
two expressions. These expressions must have identical structure: indeed, if
\tyconvisitor{expr} finds that they exhibit different tags at the root, say
\oc|EConst| versus \oc|EAdd|, then it invokes the method \tyconfail{expr},
which by default calls \oc|VisitorsRuntime.fail()|, which throws the exception
\oc|VisitorsRuntime.StructuralMismatch|.

\begin{figure}[t]
\codefollowup{expr02}
\origfirstline{expr05}{3}
\caption{Determining whether two expressions are syntactically equal}
\label{fig:expr05}
\end{figure}

An \itertwo visitor can be used, for instance, to easily determine whether two
expressions are syntactically equal (\fref{fig:expr05}). Naturally, for this
particular purpose, one could use OCaml's primitive equality operator \oc|=|,
or one could exploit \ppxderiving and annotate the type definition with
\oc|[@@deriving eq]|. Visitors offer greater flexibility: for instance, if our
arithmetic expressions contained variables, we could easily define an
operation that tests whether two expressions are equal up to a renaming of
variables.
% More generally, if expressions contained variables and binders, we could
% define an operation that tests whether two expressions are $\alpha$-equivalent.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr06}
\caption{Visitors for a family of types}
\label{fig:expr06}
\end{figure}

\subsection{Visitors for a family of types}
\label{sec:intro:family}

Visitors can be generated not just for one type definition, but for a family
of type definitions. In \fref{fig:expr06}, we propose a definition of
arithmetic expressions that involves three algebraic data types, namely
\oc|unop|, \oc|binop|, and \oc|expr|. We request the generation of two
visitors, namely an \iter visitor and a \map visitor. This causes the
generation of just two classes, named \iter and \map, respectively. Each of
these classes has visitor methods for every type (namely \tyconvisitor{unop},
\tyconvisitor{binop}, \tyconvisitor{expr}) and for every data constructor
(namely \dataconvisitor{UnaryMinus}, \dataconvisitor{BinaryMinus}, and so on).

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr09}
\vspace{-\baselineskip}
\processed{expr09}
\caption{A visitor for a parameterized type of decorated expressions}
\label{fig:expr09}
\end{figure}

\begin{figure}[p]
\codefollowup{expr09}
\origfirstline{expr10}{3}
\caption{Working with different types of decorations}
\label{fig:expr10}
\end{figure}

\subsection{Visitors for parameterized types}
\label{sec:intro:parameterized}

Visitors can be generated for parameterized types, too. (Technically, we
impose a restriction to \emph{regular} types; see \S\ref{sec:regularity}.)
%
In \fref{fig:expr09}, for instance, we define a variant of arithmetic
expressions where every tree node is decorated with a value of type
\oc|'info|. We request the generation of a \map visitor, whose code is shown
in the second part of \fref{fig:expr09}. The generated code has exactly the
same structure as in the previous sections. The only new feature is that the
class \map is now virtual, as it has a virtual method, \tyconvisitor{'info}.

The methods are \emph{not} declared polymorphic in the type
variable~\oc|'info|, or in two type variables~\oc|'info1| and~\oc|'info2|, as
one might perhaps expect. In fact, they must not be declared polymorphic:
indeed, the user who implements \tyconvisitor{'info} in a subclass of \map may
wish to provide an implementation that expects and/or produces specific types
of information.

As a result, every visitor \emph{object} is monomorphic: its method
\tyconvisitor{'info} must have type \oc|info1 ->| \oc|info2| for certain specific
types \oc|info1| and \oc|info2|. Fortunately, the visitor \emph{class} is
polymorphic: therefore, two distinct visitor objects can have distinct types.

The class \map is \emph{not} parameterized over the type variable~\oc|'info|,
or over two type variables~\oc|'info1| and~\oc|'info2|, as one might perhaps
expect. This is not necessary.%
\footnote{The class is parameterized over \oc|'self|, and that is sufficient.
  Indeed, the type \oc|'self| determines the type of all methods, including
  \tyconvisitor{'info}. Therefore, \oc|'self| determines \oc|'info|.}

\fref{fig:expr10} presents two example uses of the class \map. In the first
example, we define a function \oc|strip|, of type \oc|'info expr -> unit expr|,
which strips off the decorations in an arithmetic expression, replacing them
with unit values. In the second example, we define a function \oc|number|,
of type \oc|'info expr -> int expr|, which decorates each node in an arithmetic
expression with a unique integer number.%
\footnote{Because the \oc|info| field appears before the \oc|node| field in
  the definition of the type \oc|expr|, and because fields are visited
  left-to-right, we get a prefix numbering scheme. By exchanging these fields,
  we would get postfix numbering.}

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr11}
\vspace{-\baselineskip}
\processed{expr11}
\caption{Dealing with preexisting (parameterized) types, such as \oc|int| and \oc|list|}
\label{fig:expr11}
\end{figure}

\subsection{Dealing with preexisting types}
\label{sec:intro:nonlocal}

A type definition can contain references to the types that are being defined,
also known as \emph{local} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EAdd| contains two references to a local type, namely
\oc|expr|.

A type definition can also contain references to pre-existing types, also
known as \emph{nonlocal} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EConst| contains a reference to a nonlocal type, namely
\oc|int|, which happens to be one of OCaml's primitive types. In
\fref{fig:expr11}, the definition of \oc|EAdd| contains a reference to a
parameterized nonlocal type, namely \oc|list|, which happens to be defined in
OCaml's standard library.

The treatment of local types has been illustrated in the previous sections.
In short, for every local type, a visitor method is generated: for instance,
for the local type \oc|expr|, we generate the method \tyconvisitor{expr}.

The treatment of nonlocal types is different. We do not wish to adopt a scheme
where there is one visitor method per nonlocal type.%
%
\footnote{That would be too restrictive. For instance, imagine that a type
  definition contains references to both \oc|int list| and \oc|expr list|. If
  we relied on just one method \tyconvisitor{list}, then this method would be
  used at two different types. Because our methods are monomorphic, that would
  cause a type error. One might consider instead declaring a polymorphic
  method, or declaring multiple monomorphic methods, but neither of these
  approaches seems workable.}
%
Instead, we expect one (possibly polymorphic) visitor \emph{function} to exist
for each nonlocal type. By convention, when generating an \iter visitor, the
visitor function for the type \oc|int| must be named \oc|Int.iter|; the
visitor function for the type (parameterized) type \oc|list| must be named
\oc|List.iter|; and so on. If the type definition contains a reference to a
nonlocal user-defined type \oc|foo|, then the visitor function for this type
must be named \oc|Foo.iter|.

For every OCaml primitive type, the library module \oc|VisitorsRuntime|, which
is automatically opened in the generated code, supplies suitable visitor
functions. The module \oc|VisitorsRuntime| contains several submodules named
\oc|Int|, \oc|List|, and so on; each of them supplies four functions named
\iter, \map, \itertwo, \maptwo. (Please consult \srcFile{VisitorsRuntime.mli}
for details.)

For a user-defined type \oc|foo|, it is up to the user to ensure that a module
named \oc|Foo| can be found and offers these four functions. The \nonlocal
option (\sref{sec:nonlocal}) lets the user control where the module \oc|Foo|
is found.

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Advanced examples}
% TEMPORARY ou: applications, illustrations?
%           ou: playing with open/closed data types, tying knots, hash-consing?
\label{sec:advanced}

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr12}
\vspace{-\baselineskip}
\processed{expr12}
\caption{An open type of arithmetic expressions} % and a visitor for it
\label{fig:expr12}
\end{figure}

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr13}{3}
\caption{A closed type of arithmetic expressions}
\label{fig:expr13}
\end{figure}

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr08}{3}
\caption{A closed type of hash-consed arithmetic expressions}
\label{fig:expr08}
\end{figure}

\subsection{Visitors for open and closed data types}
\label{sec:advanced:openclosed}

The algebraic data types of arithmetic expressions shown in the previous
section (\sref{sec:intro}) are \emph{closed}. That is, the type \oc|expr|
is recursive: an expression of type \oc|expr| has subexpressions of type
\oc|expr|.

It is often desirable, for greater flexibility, to first define an \emph{open}
type of arithmetic expressions. Such a type, say \oc|oexpr|, is parameterized
over a type variable~\oc|'expr|. It is nonrecursive: an expression of type
\oc|'expr oexpr| has subexpressions of type \oc|'expr|. It is shown in
\fref{fig:expr12}. Naturally, we may request the generation of visitors for
the type \oc|oexpr|. In \fref{fig:expr12}, we generate a class of \map
visitors, which we name \oc|omap|. As explained earlier
(\sref{sec:intro:parameterized}), this class has a virtual method,
\tyconvisitor{'expr}.

The closed (recursive) type of expressions, \oc|expr|, can then be defined in
terms of \oc|expr|. This is done in \fref{fig:expr13}. In type-theoretical
terms, one would like to define \oc|expr| as the fixed point of the functor
\oc|oexpr|.
% TEMPORARY citation; demander √† Pierre-√âvariste
That is, roughly speaking, one would like to define \oc|type expr = expr oexpr|.
This is not accepted by OCaml, though;%
%
\footnote{It would be accepted by OCaml with the command line switch
  \texttt{-rectypes}, which instructs the typechecker to tolerate
  equirecursive types. However, this is \emph{not} a good idea, as it causes
  the typechecker to suddenly accept many meaningless programs and infer
  bizarre types for them.}
%
we work around this limitation by making \oc|expr| an algebraic data type
whose single data constructor is named~\oc|E|.%
%
\footnote{We mark this algebraic data type \oc|[@@unboxed]|, which (as of
  OCaml 4.04) guarantees that there is no runtime cost associated with the
  data constructor~\oc|E|. A value of type \oc|expr| is represented at
  runtime as a value of type \oc|expr oexpr|.}

Let us now construct a visitor class for the type \oc|expr|. It is easy to
do so, by hand, in a few lines of code.%
%
\footnote{We could request the generation of a visitor class via a
  \oc|[@@deriving]| annotation. However, the type \oc|oexpr| would then be
  viewed as nonlocal; therefore, we would have to first define a visitor
  function \oc|Oexpr.map| for the type \oc|oexpr|. That could be done. More
  seriously, the generated visitor class would have only one method, namely
  \tyconvisitor{expr}, so it would not be customizable by inheritance, as it
  should be.}
%
We define a class \oc|map|, a subclass of \oc|omap|, and provide a concrete
implementation of the virtual method \tyconvisitor{'expr}. In the definition
of the type \oc|expr|, the type variable \oc|'expr| is instantiated with
\oc|expr|, so the method \tyconvisitor{'expr} expects an argument of type
\oc|expr| and must return a result of type \oc|expr|. We deconstruct the
argument using the pattern \oc|E e|. Therefore, the variable \oc|e| has type
\oc|expr oexpr| and is a suitable argument to the method \tyconvisitor{oexpr}.
After this call, we perform the same step in reverse: the result of the call
has type \oc|expr oexpr|, so we wrap it in an application of the data
constructor~\oc|E| and obtain a result of type \oc|expr|.

The visitor class \oc|map| can now be used to implement transformations of
arithmetic expressions, that is, functions of type \oc|expr -> expr|. As an
example, let us implement a transformation whose effect is to double every
integer constant in an arithmetic expression. This is done in
\fref{fig:expr13double}. As expected, it suffices to construct a visitor
object that inherits \oc|map| and overrides the method
\dataconvisitor{EConst}.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr13}}
\origfirstline{expr13double}{4}
\caption{A transformation of arithmetic expressions}
\label{fig:expr13double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12}, \ref{fig:expr13}, and~\ref{fig:expr08}}
\origfirstline{expr14}{6}
\caption{Conversions between two types of arithmetic expressions}
\label{fig:expr14}
\end{figure}

\subsection{Visitors for hash-consed abstract syntax trees}
\label{sec:advanced:hashconsed}

On top of the open data type \oc|oexpr| of the previous section
(\sref{sec:advanced:openclosed}), one can define not just the closed data type
\oc|expr| of ordinary arithmetic expressions, but also other closed data types
of expressions where every node is annotated with information.

As an example, let us define a type \oc|hexpr| of hash-consed (that is,
maximally-shared) arithmetic expressions. We use Filli√¢tre and Conchon's
library~\cite{filliatre-conchon-06}, which can be found in \opam under the
name \hashcons.

The definition of the type \oc|hexpr| appears in \fref{fig:expr08}. It is
analogous to the definition of the type \oc|expr| (\fref{fig:expr13}), with an
added twist: instead of taking the fixed point of the functor \oc|_ oexpr|, we
take the fixed point of the functor \oc|_ oexpr hash_consed|. By looking up
the definition of the type \oc|hash_consed| in \hashconsRepoFile{hashcons.mli},
one finds that this means that every node in an arithmetic expression carries
certain information (namely a unique tag and a hash) that are used to enforce
maximal sharing.

Enforcing maximal sharing requires maintaining a mutable table where all
arithmetic expressions ever constructed are stored. (This is in fact a weak
hash table.) We initialize such a table by calling the function
\oc|Hashcons.create|. This table is then populated by the function \oc|h|, a smart
constructor.
% of type \oc|hexpr oexpr -> hexpr|.
This function takes a candidate expression of type \oc|hexpr oexpr| and
returns an expression of type \oc|hexpr|, which is either allocated anew
or found in the table (should an identical expression already exist).

% TEMPORARY illustration: types ouverts, ferm√©s avec hash-consing

% expr08 (hexpr)
% expr14 (moving from expr to hexpr and back)

% ------------------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{english}

\end{document}

% TEMPORARY

r√©f√©rence:
  document the option \nonlocal \label{sec:nonlocal}
  document the regularity restriction \label{sec:regularity} and the option irregular

indiquer comment voir le code engendr√©
      et comment voir son type

related work:
  ppx_deriving (generates monolithic code) (fixed number of templates)
  ppx_deriving_morphism
  Hongbo Zhang has `deriving at a distance' in Fan
    https://github.com/bobzhang/fan
    http://zhanghongbo.me/fan/
    http://zhanghongbo.me/fan/_downloads/metaprogramming_for_ocaml.pdf
